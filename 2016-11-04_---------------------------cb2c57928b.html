<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>插入排序的目标-从低到高或者从高到底的排序一个数组。</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">插入排序的目标-从低到高或者从高到底的排序一个数组。</h1>
</header>
<section data-field="body" class="e-content">
<section name="b3a0" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="499c" id="499c" class="graf graf--p graf--leading">你被给定一个数组，需要将它们放在正确的位置上，插入排序的工作流程就是这样的：<br> 1，把数组放在一堆上，这个堆是无序的。<br> 2，从堆中选择一个数字，你选择哪个无关要紧，但是最容易去从堆的顶部选择<br> 3，插入这个数字到一个新的数组中<br> 4，从无序的堆中选择下一个数组，也将那个数字插入到新数组中。它要么在你选择的第一个数组的之前或之后,所以,现在这两个数字排序。<br> 5，再次,选择下一个数桩并将其插入到数组的适当的排序位置。<br> 6，继续这样做,直到没有更多的堆。最终你会得到一个空桩和数组排序。<br> 这就是为什么我们叫它插入排序，因为你从桩拿出一个数字然后在适当的有序位置的数组中插入它。</p><h3 name="8c43" id="8c43" class="graf graf--h3 graf-after--p">eg</h3><p name="ab0a" id="ab0a" class="graf graf--p graf-after--h3">我们有一个无序的数组。[9,3,6,4,5]<br> 选择第一个数，9，插入它到一个新的数组中，目前在那个数组中没有什么，这是比较容易的。现在有序的数组是【9】，堆是 【3，6，4，5】<br> 从堆中选择一个数字，3，插入到有序的数组中，它应该在9的签名，因此现在有序的数组就是【3，9 】，堆则缩小为[6,4,5].<br> 选择下一个数字6，插入到有序的数组中，它应该在3和9之间，有序的数组此时为[3,6,9],而堆缩减为【4，5】.<br> 重复这样的步骤，知道堆里为空。</p><h3 name="60e2" id="60e2" class="graf graf--h3 graf-after--p">就地排序</h3><p name="9c2a" id="9c2a" class="graf graf--p graf-after--h3">以上的解释似乎让你觉得你应该需要二个数组：一个为无序的堆，一个则在顺序中包含这些数字。<br> 但是你能就地执行插入排序，不要去创建一个独立的数组。你仅仅保持追踪哪部分数组已经排序，哪部分在无序的堆中。<br> 起初，数组是[9,3,6,5,4],|则展示了排序部分结束和堆开始，</p><pre name="b0b2" id="b0b2" class="graf graf--pre graf-after--p">[| 9,3,6,5,4].</pre><p name="09e1" id="09e1" class="graf graf--p graf-after--pre">这显示了排序部分是空的，堆以9开始。<br> 当执行第一个数字后，我们会看到的</p><pre name="aedd" id="aedd" class="graf graf--pre graf-after--p">【9 | 3,6,5,4]</pre><p name="93ad" id="93ad" class="graf graf--p graf-after--pre">排序的部分是[8], 堆则是【3，6，5，4】,| 栏则移动了一个位置到右边。<br> 这就是在排序期间数组的目录是如何变化的过程</p><pre name="f271" id="f271" class="graf graf--pre graf-after--p">[| 9, 3, 6, 5, 4 ]<br>[ 9 | 3, 6, 5, 4 ]<br>[ 3, 9 | 6, 5, 4 ]<br>[ 3, 6, 9 | 5, 4 ]<br>[ 3, 5, 6, 9 | 4 ]<br>[ 3, 4, 5, 6, 9 |]</pre><p name="3b2e" id="3b2e" class="graf graf--p graf-after--pre">每一步，|栏向前移动一个位置，如你所见，到 |的数组开头总是有序的，桩收缩,排序部分生长,直到桩是空的,没有其他未分类的数字了。</p><h3 name="4477" id="4477" class="graf graf--h3 graf-after--p">如何插入</h3><p name="056a" id="056a" class="graf graf--p graf-after--h3">每一步你从无序堆选最顶部的数字,将其插入到排序数组的一部分。你必须把这个数字在适当的地方,以至于数组的开头保持有序。这是如何工作的呢?假设我们已经完成了前几个数组元素和看起来像这样:</p><pre name="6263" id="6263" class="graf graf--pre graf-after--p">[3,6,9 | 5,4]</pre><p name="1399" id="1399" class="graf graf--p graf-after--pre">下一个要排序的数组是5，我们需要将它插入到有序的部分的某一处，这里有一种方法去做它，看之前的元素9：比5 大吗？是的，因此5一个在9，之前，我们这二个元素会得到如下的结果</p><pre name="5ccf" id="5ccf" class="graf graf--pre graf-after--p">[3,6,5,9| 4]</pre><p name="8056" id="8056" class="graf graf--p graf-after--pre">我们仍然没有做完，新的之前的元素5，它却比6小，我们交换这二个数字</p><pre name="c27b" id="c27b" class="graf graf--pre graf-after--p">【3，5，6，9 | 4】</pre><p name="9c96" id="9c96" class="graf graf--p graf-after--pre">依次进行就可以得到有序的数组</p><pre name="81f5" id="81f5" class="graf graf--pre graf-after--p">func insertionSort(_ array: [Int]) -&gt; [Int] {<br>  var a = array                             // 1<br>  for x in 1..&lt;a.count {                    // 2<br>    var y = x<br>    while y &gt; 0 &amp;&amp; a[y] &lt; a[y - 1] {        // 3<br>      swap(&amp;a[y - 1], &amp;a[y])<br>      y -= 1<br>    }<br>  }<br>  return a<br>}</pre><p name="005a" id="005a" class="graf graf--p graf-after--pre">然后在playground中运行就会得到这样的结果</p><figure name="e66c" id="e66c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder"><img class="graf-image" data-image-id="1*fmyGpp9vATotjoQFOP9SZw.png" alt="屏幕快照 2016-11-04 下午11.07.16" src="https://cdn-images-1.medium.com/max/800/1*fmyGpp9vATotjoQFOP9SZw.png"></div></figure><p name="d0ee" id="d0ee" class="graf graf--p graf-after--figure"><br> 但是它是如何工作的呢？<br> 1，做一份数组的备份。这是必要的因为你不能直接修改数组的目录参数，像Swift本身的sort（），insertionSort()函数则将返回一个源数组的一个有序的备份。<br> 2，在这个函数内部有二个循环，外部的循环则在数组中返回的每个元素-这就是我们从堆中寻找顶部的数组。变量x是有序部分结束和堆开始的索引，必须牢记，在任何给定的时刻内，数组开始都是从0到x被排序。<br> 3，这个内部循环则着眼于在位置X处的元素，这是堆顶部的数字，它或者比值钱的元素小，内部循环穿过有序的数组向前进，每次它发现这个数字比它大，然后交换它们，当内部循环完成时，数组的开头再次是有序的，并且有序部分通过一个元素来增长。<br> Note： 外部循环从索引1开始，而不是0.移动第一个元素从堆排序部分实际上并不改变什么,所以我们不妨跳过它。</p><h3 name="19a8" id="19a8" class="graf graf--h3 graf-after--p">没有更多的交换</h3><p name="2fab" id="2fab" class="graf graf--p graf-after--h3">替代用每个先前的元素来交换，我们能移动所有这些元素一个位置到右边，然后复制新的数组到正确的位置</p><pre name="4489" id="4489" class="graf graf--pre graf-after--p">func insertionSort( _ array:[Int]) -&gt;[Int] {<br>    var a = array<br>    for x in 1..&lt;a.count {<br>    var y = x<br>    let temp = a[y]<br>    while y &gt; 0 &amp;&amp; temp &lt; a[ y-1 ] {<br>        a[y] = a [y - 1]<br>        y -= 1<br>    }<br>    a[y] = temp<br>}<br>return a<br>}</pre><h3 name="f5fa" id="f5fa" class="graf graf--h3 graf-after--pre">使它泛型化</h3><pre name="66b4" id="66b4" class="graf graf--pre graf-after--h3">func insertionSort&lt;T&gt; ( _ array:[T],_ isOrderedBefore:(T,T)-&gt;Bool) -&gt;[T] {<br>    var a = array<br>    for x in 1..&lt;a.count {<br>    var y = x<br>    let temp = a[y]<br>    while y &gt; 0 &amp;&amp; isOrderedBefore(temp,a[y -1] ){<br>    a[y] = a [y-1]<br>    y -= 1<br>    }<br>    a[y] = temp<br>    }<br>    return a<br>    }</pre><figure name="9d04" id="9d04" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder"><img class="graf-image" data-image-id="1*_pPY-v24M-3y55a95CDXrw.png" alt="屏幕快照 2016-11-04 下午11.36.15" src="https://cdn-images-1.medium.com/max/800/1*_pPY-v24M-3y55a95CDXrw.png"></div></figure><h3 name="2630" id="2630" class="graf graf--h3 graf-after--figure">性能</h3><p name="b7f0" id="b7f0" class="graf graf--p graf-after--h3 graf--trailing">插入排序是非常快,如果已经排好序的数组。这听起来很明显,但是这并不是适用于所有搜索算法。在实践中,大量的数据已经在很大程度上,如果不完全,排序,插入排序很好工作。最坏的和平均情况下插入排序的性能是O(n ^ 2)。这是因为有两个嵌套循环这个函数。其他排序算法,如快速排序和归并排序,O(n log n)性能,在大型输入速度更快。插入排序是快速排序小数组。一些标准库类功能,开关从一个快速排序,插入排序时,分区大小为10或更少。我做一个快速测试比较我们insertionSort与迅速的内置类型()()。数组的约100件左右,速度的差异很小。然而,随着输入变得更大,O(n ^ 2)迅速开始执行很多比O(n log n)和插入排序就跟不上。</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/插入排序" class="p-tag">插入排序</a></p><p>By <a href="https://medium.com/@ZhaoPink" class="p-author h-card">Marc Steven</a> on <a href="https://medium.com/p/cb2c57928b"><time class="dt-published" datetime="2016-11-04T15:58:34.006Z">November 4, 2016</time></a>.</p><p><a href="https://medium.com/@ZhaoPink/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%AE%E6%A0%87-%E4%BB%8E%E4%BD%8E%E5%88%B0%E9%AB%98%E6%88%96%E8%80%85%E4%BB%8E%E9%AB%98%E5%88%B0%E5%BA%95%E7%9A%84%E6%8E%92%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84-cb2c57928b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 23, 2017.</p></footer></article>

</body></html>
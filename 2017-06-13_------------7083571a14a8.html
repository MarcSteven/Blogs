<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>结构型模式之适配器模式</title><meta name="description" content="适配器模式是什么呢？"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">结构型模式之适配器模式</h1>
</header>
<section data-field="subtitle" class="p-summary">
适配器模式是什么呢？
</section>
<section data-field="body" class="e-content">
<section name="c64a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5891" id="5891" class="graf graf--h3 graf--leading graf--title">结构型模式之适配器模式</h3><p name="17d3" id="17d3" class="graf graf--p graf-after--h3">适配器模式是什么呢？</p><p name="4c6a" id="4c6a" class="graf graf--p graf-after--p">它允许二个对象提供相关的函数去一起工作，尽管它们存在不兼容的API。</p><p name="edee" id="edee" class="graf graf--p graf-after--p">这中间是需要一个适配器去从一个组件映射到另外的组件。</p><p name="705c" id="705c" class="graf graf--p graf-after--p">它的福利：它允许你使得组件融入你不再进入你的App修改源码，这是一个普遍的问题，当我们使用第三方库的框架或者你正在从另外的工程中耗尽输出。</p><p name="0da9" id="0da9" class="graf graf--p graf-after--p">使用的时机：当你需要在你的App中融入提供相似的函数给其他组件的一个组件，但是却使用的是不兼容的API去使用的时候，你就应该考虑适配器模式。</p><p name="3b4e" id="3b4e" class="graf graf--p graf-after--p">不要使用：当你能修改你想融入的组件的源码或者它可能被进入你App的组件移除数据提供。</p><p name="180f" id="180f" class="graf graf--p graf-after--p">如何确认你是否使用正确？当适配器允许组件被融入App（没有要求App的修改或者组件的修改）</p><p name="24d5" id="24d5" class="graf graf--p graf-after--p">它的痛点：试图扩展了模式去强制一个组件的结合-对于被适配的对象却没有提供想要的函数的API</p><p name="e6e6" id="e6e6" class="graf graf--p graf-after--p">这个模式解决了什么问题？</p><p name="d4a0" id="d4a0" class="graf graf--p graf-after--p">当已经一个存在的系统需要融入一个新的组件（有一个相似的函数，但是并未呈现普遍的接口，并且不能被修改），适配器模式解决了递增问题。</p><p name="d675" id="d675" class="graf graf--p graf-after--p">它的实现过程如图所示：</p><figure name="7026" id="7026" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 560px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 80%;"></div><img class="graf-image" data-image-id="1*sFoh0BX9O99CWKDBvD4dKA.png" data-width="1280" data-height="1024" src="https://cdn-images-1.medium.com/max/800/1*sFoh0BX9O99CWKDBvD4dKA.png"></div></figure><p name="ef09" id="ef09" class="graf graf--p graf-after--figure">共计5个步骤</p><p name="4708" id="4708" class="graf graf--p graf-after--p">1，从应用到使用它期望一起工作的API的适配器发送请求</p><p name="fb59" id="fb59" class="graf graf--p graf-after--p">2，适配器运用自身共有的API的知识去选择一个组件方法或者属性去处理这个请求</p><p name="f001" id="f001" class="graf graf--p graf-after--p">3.组件接受了适配器的请求，做它的工作，并且返回结果给适配器</p><p name="5a83" id="5a83" class="graf graf--p graf-after--p">4，适配器使用它共有的API的知识去转换通过客户端提供的结果进入App期望要的结果。</p><p name="2c45" id="2c45" class="graf graf--p graf-after--p">5，最后返回结果</p><p name="77b7" id="77b7" class="graf graf--p graf-after--p">在App和组件中，并非意识到彼此的存在。</p><p name="1673" id="1673" class="graf graf--p graf-after--p">它的具体实现：</p><figure name="07bb" id="07bb" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 742px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 106%;"></div><img class="graf-image" data-image-id="1*VLG1cKYPXivyg68uDnvAdA.png" data-width="804" data-height="852" src="https://cdn-images-1.medium.com/max/800/1*VLG1cKYPXivyg68uDnvAdA.png"></div></figure><p name="72af" id="72af" class="graf graf--p graf-after--figure">关于适配器模式的更好应用，可以参考Instagram公司的工程师开源的一个框架IGListKit，下面是它的结构:</p><figure name="44f4" id="44f4" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 354px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 50.6%;"></div><img class="graf-image" data-image-id="1*yYOrXAeMTg46jwpL7x-iyQ.png" data-width="1478" data-height="748" src="https://cdn-images-1.medium.com/max/800/1*yYOrXAeMTg46jwpL7x-iyQ.png"></div></figure><p name="273e" id="273e" class="graf graf--p graf-after--figure">它的主要特性：</p><figure name="9ec2" id="9ec2" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 396px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.49999999999999%;"></div><img class="graf-image" data-image-id="1*4SpSEI4_j8Py4IBTwvII7w.png" data-width="1348" data-height="762" src="https://cdn-images-1.medium.com/max/800/1*4SpSEI4_j8Py4IBTwvII7w.png"></div></figure><p name="165d" id="165d" class="graf graf--p graf-after--figure">1，可扩展的API</p><p name="50d5" id="50d5" class="graf graf--p graf-after--p">2，对于重用的Cell和组件架构更合理</p><p name="be3e" id="be3e" class="graf graf--p graf-after--p">3，解耦神话的算法</p><p name="fce8" id="fce8" class="graf graf--p graf-after--p">4，再也不需要调用reloadData等</p><p name="58b1" id="58b1" class="graf graf--p graf-after--p">5，创建多种数据类型的集合视图</p><p name="cb8f" id="cb8f" class="graf graf--p graf-after--p">6，完全支持单元测试</p><p name="a3a5" id="a3a5" class="graf graf--p graf-after--p">7，用OC写的但是兼容Swift</p><p name="a76a" id="a76a" class="graf graf--p graf-after--p graf--trailing">更多内容，可参考<a href="https://github.com/Instagram/IGListKit" data-href="https://github.com/Instagram/IGListKit" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/Instagram/IGListKit</a></p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/ios" class="p-tag">iOS</a></p><p>By <a href="https://medium.com/@ZhaoPink" class="p-author h-card">Marc Steven</a> on <a href="https://medium.com/p/7083571a14a8"><time class="dt-published" datetime="2017-06-13T14:53:11.469Z">June 13, 2017</time></a>.</p><p><a href="https://medium.com/@ZhaoPink/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-7083571a14a8" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 23, 2017.</p></footer></article>

</body></html>
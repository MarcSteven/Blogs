<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>iOS 中的传值问题</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">iOS 中的传值问题</h1>
</header>
<section data-field="body" class="e-content">
<section name="cda2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="9a1a" id="9a1a" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">正向传值：A-&gt;B，属性传值</strong><br> ViewControllerA -ViewControllerB<br> 1，在”viewControllerB.h “中创建一个属性</p><pre name="6ff6" id="6ff6" class="graf graf--pre graf-after--p">@property(nonatomic,assign) BOOL  isSomethingEnabled;</pre><p name="8a19" id="8a19" class="graf graf--p graf-after--pre">2,在ViewControllerA中你需要告诉它关于ViewControllerB，因此你应该这样做：</p><pre name="4b8b" id="4b8b" class="graf graf--pre graf-after--p">#import &quot;ViewControllerB.h&quot;</pre><p name="9db8" id="9db8" class="graf graf--p graf-after--pre">然后你想加载视图，例如 didSelectRowAtIndex 或者 一些 IBAction，你需要在你传送它到一个导航栈之前在ViewControllerB中设置属性。</p><pre name="29d8" id="29d8" class="graf graf--pre graf-after--p">ViewControllerB *viewControllerB - [[ViewControllerB alloc]initWithNib:@&quot;ViewControllerB&quot; bundle:nil];<br>viewControllerB,isSomethingEnabled = YES;<br>[self pushViewController:viewControllerB animated:YES];</pre><p name="3634" id="3634" class="graf graf--p graf-after--pre">这就在ViewControllerB中设置属性为YES了。<br> 以上就为属性传值。</p><h3 name="8dda" id="8dda" class="graf graf--h3 graf-after--p">使用segues传值</h3><p name="e503" id="e503" class="graf graf--p graf-after--h3">如果你使用Storyboard，并且你喜欢使用Segues。<br> 1，在”viewControllerB.h “中创建一个属性</p><pre name="6050" id="6050" class="graf graf--pre graf-after--p">@property(nonatomic,assign) BOOL  isSomethingEnabled;</pre><p name="8161" id="8161" class="graf graf--p graf-after--pre">2，在ViewControllerA中你需要告诉它关于ViewControllerB，因此你应该这样做：</p><pre name="382e" id="382e" class="graf graf--pre graf-after--p">#import &quot;ViewControllerB.h&quot;</pre><p name="94ee" id="94ee" class="graf graf--p graf-after--pre">3，在storyboard上从ViewControllerA 到ViewControllerB创建一个segue，给它一个标示符，例如给它“showDetailSegue”<br> 4，当任何segue被执行时需要增加方法给ViewControllerA，因为我们需要检测哪个segue被调用，然后再确认做哪些事</p><pre name="21b9" id="21b9" class="graf graf--pre graf-after--p">-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{<br>    if([segue.identifier isEqualToString:@&quot;showDetailSegue&quot;]){<br>        ViewControllerB *controller = (ViewControllerB *)segue.destinationViewController;<br>        controller.isSomethingEnabled = YES;<br>    }<br>}</pre><p name="f609" id="f609" class="graf graf--p graf-after--pre">如果你的视图是建立在导航控制器上，你需要改变方法</p><pre name="3725" id="3725" class="graf graf--pre graf-after--p">-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{<br>    if([segue.identifier isEqualToString:@&quot;showDetailSegue&quot;]){<br>        UINavigationController *navController = (UINavigationController *)segue.destinationViewController;<br>        ViewControllerB *controller = (ViewControllerB *)navController.topViewController;<br>        controller.isSomethingEnabled = YES;<br>    }<br>}</pre><p name="cd28" id="cd28" class="graf graf--p graf-after--pre">如此就完成了上面的动作</p><h3 name="265c" id="265c" class="graf graf--h3 graf-after--p">反向传值</h3><p name="958b" id="958b" class="graf graf--p graf-after--h3">从ViewControllerB 传值到ViewControllerA ，你需要用协议，委托或者Block。<br> 我们例子中使用委托，你使得viewControllerA成为ViewControllerB的委托，这就使得viewcontrollerB发回一个消息到ViewControllerA上。<br> 1，在viewControllerB.h<br> 中，“#import”上面，但是“interface上面”</p><pre name="4e47" id="4e47" class="graf graf--pre graf-after--p">@class ViewControllerB<br>@protocol ViewControllerDelegate&lt;NSObject&gt;<br>- (void)addItemViewController:(ViewControllerB *) controller didFinishEnteringItem:(NSString *) item;</pre><p name="35a7" id="35a7" class="graf graf--p graf-after--pre">2,接下来，在“ViewControllerB.h”中，你需要安装一个委托的属性，并且.m 中同步它</p><pre name="86dd" id="86dd" class="graf graf--pre graf-after--p">@property (nonatomic,weak) id &lt;ViewControllerBDelegate&gt; delegate;</pre><p name="6fb8" id="6fb8" class="graf graf--p graf-after--pre">3,在viewControllerB当我们pop 一个视图控制器时，在delegate上调用一个message</p><pre name="762a" id="762a" class="graf graf--pre graf-after--p">NSString *item = @&quot;Swift coders&quot;;<br>[self.delegate addItemViewController:self  didFinishEnterItem:item];</pre><p name="60c8" id="60c8" class="graf graf--p graf-after--pre">4, 之前都是viewControllerB，此时到了ViewControllerA。导入import “ViewControllerB.h”,然后让其遵从它的协议</p><pre name="6672" id="6672" class="graf graf--pre graf-after--p">#import  &quot;ViewControllerB.h&quot;<br>@interface ViewControllerA:UIViewController&lt;ViewControllerBDelegate&gt;</pre><p name="4b9c" id="4b9c" class="graf graf--p graf-after--pre">5,在 ViewControllerA.m实现这个方法</p><pre name="4137" id="4137" class="graf graf--pre graf-after--p">- (void)addItemViewController:(ViewControllerB *)controller didFinishEnteringItem:(NSString *)item<br>{<br>    NSLog(@&quot;This was returned from ViewControllerB %@&quot;,item);<br>}</pre><p name="246f" id="246f" class="graf graf--p graf-after--pre">6，在推送到ViewControllerB到一个导航栈之前你要告诉ViewControllerB-ViewControllerA是它的委托，否则我们会得到一个错误</p><pre name="13a4" id="13a4" class="graf graf--pre graf-after--p">ViewControllerB *viewControllerB = [[ViewControllerB alloc] initWithNib:@&quot;ViewControllerB&quot; bundle:nil];<br>viewControllerB.delegate = self<br>[[self navigationController] pushViewController:viewControllerB animated:YES];</pre><p name="0c10" id="0c10" class="graf graf--p graf-after--pre">以下场景1：</p><p name="23d3" id="23d3" class="graf graf--p graf-after--p"><br> 这是App里的二个视图控制器，ViewControllerA 是一个数据入口的格式，而ViewControllerB则是产品列表，当你选择产品列表时候，它必须在一个数据入口格式的文本盒子内呈现的选项，在这个场景中，ViewControllerA 与ViewControllerB直接交互，没有其他视图控制器。<br> 解决方案：<br> 1，segues<br> 2，delegates<br> 3，直接设置属性在视图控制器上<br> 4，NSUserDefaults，事实上是一个很差的选择。<br> 场景二：</p><p name="4c21" id="4c21" class="graf graf--p graf-after--p graf--trailing"><br> 1，ViewControllerA — Luxury Items<br> 2，ViewControllerB — Non-insured Items<br> 3，ViewControllerC — Entire Home Inventory<br> 4，ViewControllerD — Add New Item Form<br> 解决方案：<br> 观察者模式：KVO 和NSNotification<br> 单例模式</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/ios-tips" class="p-tag">Ios Tips</a>, <a href="https://medium.com/tag/ios-development" class="p-tag">Ios Development</a></p><p>By <a href="https://medium.com/@ZhaoPink" class="p-author h-card">Marc Steven</a> on <a href="https://medium.com/p/78f075682479"><time class="dt-published" datetime="2016-10-14T02:58:49.143Z">October 14, 2016</time></a>.</p><p><a href="https://medium.com/@ZhaoPink/ios-%E4%B8%AD%E7%9A%84%E4%BC%A0%E5%80%BC%E9%97%AE%E9%A2%98-78f075682479" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 23, 2017.</p></footer></article>

</body></html>
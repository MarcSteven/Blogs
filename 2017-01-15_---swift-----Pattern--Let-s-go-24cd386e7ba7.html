<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>什么是swift中的模式？Pattern？？Let’s go</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">什么是swift中的模式？Pattern？？Let’s go</h1>
</header>
<section data-field="body" class="e-content">
<section name="96e3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="456f" id="456f" class="graf graf--p graf--leading">在swift中，模式代表的是一个单一值或者复合值的结构，基于如此，因此模式并不仅仅代表一个值，相反它代表的是一个匹配给定结构的范围<br> 一个元组的模式如下所示</p><pre name="5b1e" id="5b1e" class="graf graf--pre graf-after--p">（x,y,z）</pre><p name="6dfe" id="6dfe" class="graf graf--p graf-after--pre">需要注意的是它并未包含值，相反它代表的是元组的结构，包含了三个元素</p><p name="d035" id="d035" class="graf graf--p graf-after--p">标示符模式- 以下例子就是一个用switch语句内匹配不同值的模式，当然也可以在if语句内用标示符，使用if的时候首先一个赋值运算符然后我们试图去匹配值</p><pre name="1308" id="1308" class="graf graf--pre graf-after--p">let value = 1<br>swift value {<br>case 1:<br>print(&quot;matched 1&quot;)<br>case 2:<br>print(&quot;matched 2&quot;)<br>default:<br>print(&quot;not matched&quot;)<br><br><br><br><br> let a  = 10<br> if case 10 = a {<br> print(a)<br> }</pre><p name="96b7" id="96b7" class="graf graf--p graf-after--pre">wildcard pattern -最为放纵的模式类型，用下划线_ 来代表，然后匹配和它比较的任何值，包含nil，当我们不关心被匹配的值的时候我们可以使用wildcard 模式， talk is cheap，show me the code</p><pre name="184c" id="184c" class="graf graf--pre graf-after--p">var x =5<br>for _ in 1...5{<br>x *= 3<br>}<br>print(x)</pre><p name="621f" id="621f" class="graf graf--p graf-after--pre">在wildcard模式中本质上扮演的是一个占位符，一个指针到Swift仅仅简单的匹配或者擦写它所要比较的值。当然我们也可以在if语句内使用，以下是例子,它的使用场景很广泛，如果你不在意它的值，可以使用它，你可以结合元组和枚举使用它</p><pre name="aa00" id="aa00" class="graf graf--pre graf-after--p">let a = 20<br> if case _ = a {<br> print(a)<br> }</pre><p name="6d6c" id="6d6c" class="graf graf--p graf-after--pre">值绑定模式</p><p name="bb2d" id="bb2d" class="graf graf--p graf-after--p">元组模式<br> 首先元组必须保证元组内的元素是同一类型,代码说明之</p><pre name="d96f" id="d96f" class="graf graf--pre graf-after--p">let   myTuple = [(2,&quot;Hello&quot;),(3,&quot;swift&quot;),(1,&quot;hello&quot;)]<br>for tuple in myTuple {<br>swift tuple {<br>case(_,&quot;Hello&quot;) :<br>print(tuple.0)<br>default:<br>print(&quot;didn&#39;t match&quot;)<br><br>}</pre><p name="419e" id="419e" class="graf graf--p graf-after--pre">一件事情你必须注意，如果我们使用元组模式-仅仅包含一个单一的模式，围绕元组模式的圆括号没有效果，它是自己提供一个提供单一模式的对等</p><pre name="a1b5" id="a1b5" class="graf graf--pre graf-after--p">switch 20 {<br>case (20): <br>print(&quot;matched&quot;)<br>default:<br>print(&quot;not matched&quot;)<br>}</pre><p name="5241" id="5241" class="graf graf--p graf-after--pre">以上例子，我们使用了swift语句内，当然我们可以使用其他语句例如if ，while，guard 或 for -in语句</p><pre name="4a6c" id="4a6c" class="graf graf--pre graf-after--p">let myTuple = (100,80)<br> if case (100,80) = myTuple {<br> print(&quot;\(myTuple.0),\(myTuple.1)&quot;)<br> }<br>  let (month,days):(String,Int) = (&quot;Jul&quot;,30)<br>  //for-in example <br>  let myTuple = [(2,&quot;Hello&quot;),(3,&quot;Swift&quot;),(1,&quot;Hello&quot;)]<br>  for case (_,&quot;Hello&quot;) in myTuple {<br>  print(&quot;Matched&quot;)<br>  }</pre><p name="529b" id="529b" class="graf graf--p graf-after--pre">注意：当你在for-in语句或者一个变量或常量的局部声明时，元组模式能仅仅包含其他wildcard，标示符，元组和可选值模式，在实际中这没有什么大不了的，但是你要当心</p><p name="f512" id="f512" class="graf graf--p graf-after--p graf--trailing">枚举事件模式<br> 可选值模式<br> 类型推断模式<br> 表达式模式</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/模式匹配" class="p-tag">模式匹配</a></p><p>By <a href="https://medium.com/@ZhaoPink" class="p-author h-card">Marc Steven</a> on <a href="https://medium.com/p/24cd386e7ba7"><time class="dt-published" datetime="2017-01-15T00:39:49.732Z">January 15, 2017</time></a>.</p><p><a href="https://medium.com/@ZhaoPink/%E4%BB%80%E4%B9%88%E6%98%AFswift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F-pattern-lets-go-24cd386e7ba7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 23, 2017.</p></footer></article>

</body></html>
# 引起rails application中断的普遍错误
Author:[@Marc Steven](https://twitter.com/marcstevencoder)
---
每个人都犯错，这些中的一些错误有些是早期开发时候可以捕捉的，在写代码期间，本地化测试或者代码审查过程中。不幸的是一些隐性的错误狡猾地出现在生产环境。
对于以上这些的rails应用而言，是真的。在这篇文章中，我非常乐于去分享我多次在实战中的错误，然而并发如此，我将会列举方案去如何消除他们，这比学习他人的错误更加好。
## 1，泛滥配置线程和数据连接的数量
让我们以三个简单的问题来开始
1. 你的应用使用的平均值有多少个连接到数据库
2. 你在哪里检查这个数量
3. 你的数据库能做的最大的连接数
去消除潜在的生产中断你应该知道上面的所有的答案，去更好的举例说明问题，让我们假定你使用 puma 在集群模式下作为一个web 服务器去主持在一个虚拟机器上。我们设置：
* 最大线程到16
* 最大的worker处理器到2
多少个连接到数据库应用是可以打开的，我们有二个worker 16个线程，因此总计是2 * 16 = 32个连接，但是等等，它足够吗？经常性的不够，根据gem中的README的描述：
此外，请注意Puma为内部目的(例如处理速度较慢的客户机)自行创建线程。因此，即使您指定-t 1:1(其中第一个数字是线程的最小数量，第二个是最大数量)，您的应用程序中也会创建大约7个线程。
去更好的准备，我们需要确认至少一些额外的连接位置，40个可用的数据库连接对于如此一个应用将是一个出发点。然而我们将会遭遇下面的错误和第一个生产中断
`ActiveRecord::ConnectionTimeoutError - could not obtain a database connection within 5 seconds`

经常性的，有时候，当你的每秒请求次数增长的时候，这里有一个需要去调整worker的数量和线程的数量。这是为什么它是如此重要的能提供准确的答案从三个问题。
理论而言，这里一个有地方监控将自动地通知我们-在我们超过可用的数据库连接限制之前
## 2 不正确的参数处理
JSON,String或者Symbol。我经常性问我自己相同的问题：
我如何存取解析的json响应的元素，我应该用 json['key'] 或者  json[:key]？好，尽管一个答案似乎显而易见，一个愚蠢的错误或者生产中断是准备着
`
json_response = "{\"name\": \"Igor\"}"
=> "{\"name\": \"Igor\" }"
parsed_json_response = JSON.parse(json_response)
=> {"name"=>"Igor"}
parsed_json_response["name"]
=> "Igor"
parsed_json_response[:name]
=> nil
`
你知道你能传送 "sybolize_names “ 选项到一个  JSON。parse方法
`symbolized = JSON.parse(json_response, symbolize_names: true)
=> {:name=>"Igor"}
symbolized['name']
=> nil
symbolized[:name]
=> "Igor"`
此外，在Rails中定义了HashWithIndifferentAccess类，您可以从中受益。因此，您可以使用字符串和符号符号符号访问解析后的响应的元素。
`indifferent = JSON.parse(json_response).with_indifferent_access
=> {"name"=>"Igor"}
indifferent_answer_json_response['name']
=> "Igor"
indifferent_answer_json_response[:name]
=> "Igor"
`
更确切地说，要始终记住用正确的数据结构编写测试。我发现自己在编写测试时多次使用mocks返回哈希对象而不是JSON(准确地说是字符串)。因此，我使用json[:key]符号访问它的元素。测试是绿色的，但是一个新特性没有像预期的那样工作。

最后，总是尽可能快地测试/调用编写的代码，在本地或不可能的情况下，在预生产环境中进行测试。越快越好。
## 3 缺少HTTP通信的回退响应
您的应用程序依赖于多少内部和外部服务?在微服务和SaaS解决方案的时代，这个问题的答案很少是零。

我再问你一个问题。这些服务中有多少可以被关闭，而最终用户仍然可以毫无问题地使用该应用程序?我敢打赌,这个问题的答案更接近零🙂

当您编写负责从其他服务获取数据的代码时，总是要问自己一个简单的问题:当服务宕机时，我的应用程序将会发生什么?我可以提示你，显示一个有500个错误代码的白色屏幕不是最好的主意。遗憾的是，这个问题没有灵丹妙药。我可以提供一些我已经应用过的想法:
1. 如果获取的数据不经常更改，则将其存储在应用程序缓存中，以减少HTTP请求的数量。
2. 检查是否设置了HTTP缓存头。它们使数据可以通过不同的缓存(浏览器、nginx等)进行缓存。
3. 在应用程序中挽救一个错误并返回一个回退响应(不过要记录错误)。如果您期望一个包含n个元素的数组，则返回一个空数组。
4. 如果发生错误，通知用户问题，并(如果可能)显示一个按钮重试失败的请求
5. 存储失败的请求，并在一段时间后异步重试它们。允许用户继续
6. 在向用户显示错误之前，引入指数回退来重试失败的请求。
如你所看到的，一个解决方案需要基于一个具体的场景去选择，但是这上面的几点比一个500的错误码的空白屏幕更好
## 4 缺少或者不正确的超时设置
另外一点，另外的问题，你的应用消减一个通过HTTP协议的用户浏览器请求之前去传送
Rails默认不控制请求周期，这一点和puma的web服务器是一样有效的，Chromium浏览器有一个socket的请求超时设定-5分钟，这对于我们作为一个开发者而言意味着什么？。让我们从第一点返回。带有2个worker和16个线程每个worker，共计32个线程
如果app有公共的API节点对于一些原因（）像一个重量级的查询用一个缺失的索引在数据库表中，变得无响应，响应时间变为分钟代替到秒，这是足够去启动仅有的32个虚拟请求到节点去组织app接受其他请求，所有可用的线程将会占据等待服务器响应
你将会做什么？介绍 rack-timeout gem 将会分离持续如此长的请求，这个gem将会抛出异常，一个请求被削减 ，一个占用的线程能从一个队列中处理下个请求
当介绍这个gem的时候它是重要的知道在你App的前面是什么类型的HTTP 服务器（像nginx），它有超时设置吗？Application的超时应该比在HTTP服务器上设置请求超时优先级更低，然而，这个服务器或许消减请求（在一个app完成处理它之前）
## 5 缺少DDoS/HTTP洪水保护
在我的IP被阻止并且我不能再做进一步的请求之前，我能用不正确的登录和密码组合对你的应用程序做多少HTTP请求?

尽管可以在不同的级别上实现防止DDoS(分布式拒绝服务)的机制，但由于开源社区的存在，我们可以直接在Ruby on Rails应用程序中实现。

让我们来看看rack-attack gem。它的文档和现成的示例配置很容易阅读，因此我将在这里跳过其他的使用说明。如果您没有任何反ddos解决方案，我建议您介绍gem。DDoS攻击已经造成了太多的生产中断。
## 总结

上述问题可能发生在任何Ruby on Rails应用程序中。我希望您今天能学到一些东西，从而使您开发的应用程序更加稳定和安全。这是我们的责任。

如果您遇到任何导致停机的其他问题，请在评论中与我们分享。我想向你学习🙂

##标注

我在方括号中写了maximum，因为Puma提供了基于当前流量的线程自动scalling，并且最小线程数可能低于maximum。


## 文章引用：[Common mistakes that cause ruby on rails app outages](https://frontdeveloper.pl/2019/01/common-mistakes-that-cause-ruby-on-rails-apps-outages/)



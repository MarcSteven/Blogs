<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>iOS App性能之响应篇</title><meta name="description" content="App 响应性能"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">iOS App性能之响应篇</h1>
</header>
<section data-field="subtitle" class="p-summary">
App 响应性能
</section>
<section data-field="body" class="e-content">
<section name="fdb1" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="dfab" id="dfab" class="graf graf--h3 graf--leading graf--title">iOS App性能之响应篇</h3><p name="ed2b" id="ed2b" class="graf graf--p graf-after--h3">App 响应性能</p><p name="999e" id="999e" class="graf graf--p graf-after--p">1.启动时间是响应的第一个措施</p><p name="7bef" id="7bef" class="graf graf--p graf-after--p">2，App用放大的动画并行地启动-iphone 400ms，iPad 500ms。</p><p name="b6e1" id="b6e1" class="graf graf--p graf-after--p">当心看门狗</p><p name="6c6c" id="6c6c" class="graf graf--p graf-after--p">1，如果它启动缓慢，系统开门狗将会终止app</p><p name="06b8" id="06b8" class="graf graf--p graf-after--p">2，当调试的时候，Xcode使得看门狗不能正常运转</p><p name="94e1" id="94e1" class="graf graf--p graf-after--p">3，超时之前用户放弃使用</p><p name="0064" id="0064" class="graf graf--p graf-after--p">控制启动时间-选择一个节点</p><p name="f40d" id="f40d" class="graf graf--p graf-after--p">1，看门狗关心第一个CA交易的结束</p><p name="365e" id="365e" class="graf graf--p graf-after--p">eg 第一个布局和绘画；当前在[UIApplication _reportAppLaunchFinished]</p><p name="b82b" id="b82b" class="graf graf--p graf-after--p">2,用户可能关心其他公制</p><p name="4db7" id="4db7" class="graf graf--p graf-after--p">-相机App应该控制时间授权给快门</p><p name="5a2f" id="5a2f" class="graf graf--p graf-after--p">3，日志时间到第一帧</p><p name="a519" id="a519" class="graf graf--p graf-after--p">a，在main函数中得到启动时间</p><p name="4cbf" id="4cbf" class="graf graf--p graf-after--p">4,用time profiler去控制时间到第一帧</p><p name="ab71" id="ab71" class="graf graf--p graf-after--p">a，开关到CPU策略视图</p><p name="eb7c" id="eb7c" class="graf graf--p graf-after--p">b,为reportapplicationfinished查找</p><p name="b94c" id="b94c" class="graf graf--p graf-after--p">c，发现最后样品包含的applaunchFinished</p><p name="1823" id="1823" class="graf graf--p graf-after--p">App启动阶段</p><p name="d9c9" id="d9c9" class="graf graf--p graf-after--p">1，链接和加载-在time profiler中的dyld中显现；库被映射进入地址空间；绑定被安排；静态初始化器运行</p><p name="1b43" id="1b43" class="graf graf--p graf-after--p">a：最小化链接的框架：每一个OC框架增加了较少的时间和内存消耗；消除链接不必要的框架</p><p name="ac76" id="ac76" class="graf graf--p graf-after--p">b：可选的框架：可选的框架或许引起链接器去做额外的工作；不要标记必要的库作为可选的；部署目标后用可选的给发布的框架</p><p name="f145" id="f145" class="graf graf--p graf-after--p">c：消除静态的初始化器：消除生成全局的C++对象：例如</p><p name="d5c8" id="d5c8" class="graf graf--p graf-after--p">static std：：map&lt;int,int&gt; GlobalMap = {{1,2},{3,4},{5,6}};</p><p name="b4de" id="b4de" class="graf graf--p graf-after--p">消除在加载时间内的代码；在主函数之前引起额外的代码总是运行；显式地初始化器在运行时中去代替</p><p name="0ebc" id="0ebc" class="graf graf--p graf-after--p">2，UIKit初始化：字体，状态栏，用户默认，主要的nib初始化</p><p name="6c0e" id="6c0e" class="graf graf--p graf-after--p">a:最小化主要Nib文件的大小</p><p name="7b10" id="7b10" class="graf graf--p graf-after--p">b：在偏好设置中别存储太多的数据；偏好设置以PLIST的格式来存储；属性列表是被立刻deserialized</p><p name="8273" id="8273" class="graf graf--p graf-after--p">3，应用回调：UIKit调用进入你的代码去完成启动，调用willFinishLaunchingWithIOptions；存储应用状态；调用已经完成启动；你的应用现在处在控制中</p><p name="3fee" id="3fee" class="graf graf--p graf-after--p">4，第一个核心动画转换</p><p name="159c" id="159c" class="graf graf--p graf-after--p">显现作为时间在-通常发生在runloop的结束，通常发生在启动后的报告启动</p><p name="6438" id="6438" class="graf graf--p graf-after--p">耗费的主要阶段：</p><p name="6b60" id="6b60" class="graf graf--p graf-after--p">准备阶段：解压缩图片</p><p name="fe79" id="fe79" class="graf graf--p graf-after--p">布局：所有层的大小-layoutSubViews</p><p name="a82b" id="a82b" class="graf graf--p graf-after--p">绘画：drawRect</p><p name="da4a" id="da4a" class="graf graf--p graf-after--p">最佳实践：</p><p name="39a5" id="39a5" class="graf graf--p graf-after--p">不要做它</p><p name="bafe" id="bafe" class="graf graf--p graf-after--p">消除不必要的工作-轮廓纰漏无用的工作，例如比必要的阴影和遮罩；同样数据的多次请求；在启动时间内大量的日志</p><p name="b9bf" id="b9bf" class="graf graf--p graf-after--p">不要再做它：重用代替重建</p><p name="ea90" id="ea90" class="graf graf--p graf-after--p">1.特定的类是昂贵的初始化：tableview cells 。Date/number formatter，正则表达式，SQL语句</p><p name="4c9d" id="4c9d" class="graf graf--p graf-after--p">对于通常使用的格式：</p><p name="c44f" id="c44f" class="graf graf--p graf-after--p">a，每个日期格式缓存一个格式器；2，在NSLocaleDidChangeNotification中使得缓存无效</p><p name="1987" id="1987" class="graf graf--p graf-after--p">b，日历，调用NSLog生成一个新的日历给每行日志</p><p name="2011" id="2011" class="graf graf--p graf-after--p">-消除过多调用NSLog；Calling +[NSCalendar currentCalendar】对于每次调用返回一个新的实例；如果重复使用的话则保存这个实例</p><p name="da71" id="da71" class="graf graf--p graf-after--p">c：SQLite语句：每个SQL语句都是一个编译语言，编译SQL查找进入位码；使用绑定参数和重用准备的语句</p><p name="e1e7" id="e1e7" class="graf graf--p graf-after--p">const char *query = “SELECT * FROM TRACKS WHERE id=?”;</p><p name="3452" id="3452" class="graf graf--p graf-after--p">sqlite3_prepare_v2(db, query, -1, &amp;stmt, NULL);</p><p name="fe91" id="fe91" class="graf graf--p graf-after--p">sqlite3_bind_int(stmt, 1);</p><p name="5ff5" id="5ff5" class="graf graf--p graf-after--p">更快地做它：工作效率-选择正确的数据结构和算法-提及的是collection程序主题；选择更快的算法</p><p name="7b18" id="7b18" class="graf graf--p graf-after--p">数据格式：a，属性列表主要是针对小块数据：用二进制格式给属性列表，在它里面必须deserialize完整的属性列表去存取一个单一对象</p><p name="61cc" id="61cc" class="graf graf--p graf-after--p">b:特定的API在属性列表下面被实现 — — 偏好设置，连载通过NSCoding</p><p name="1b8d" id="1b8d" class="graf graf--p graf-after--p">c：使用CoreData或者SQLite去存取大量的数据-允许递增的加载</p><p name="54b3" id="54b3" class="graf graf--p graf-after--p">d:最优化数据库</p><p name="24e3" id="24e3" class="graf graf--p graf-after--p">查找发现最慢的查找使用sqlite3_trace和sqlite_profile</p><p name="8d00" id="8d00" class="graf graf--p graf-after--p">static void profile(void *context, const char *sql, sqlite3_uint64 ns) {</p><p name="18b2" id="18b2" class="graf graf--p graf-after--p">syslog(LOG_WARNING, “Query: %s\n”, sql);</p><p name="a174" id="a174" class="graf graf--p graf-after--p">syslog(LOG_WARNING, “Execution Time: %llu ms\n”, ns / 1000000);</p><p name="0687" id="0687" class="graf graf--p graf-after--p">}</p><p name="ec72" id="ec72" class="graf graf--p graf-after--p">sqlite3_profile(conn, &amp;profile, NULL);</p><p name="15b0" id="15b0" class="graf graf--p graf-after--p">理解造成困难的查找-用EXPLAIN QUERY PLAN</p><p name="3503" id="3503" class="graf graf--p graf-after--p">sqlite3&gt; EXPLAIN QUERY PLAN</p><p name="c501" id="c501" class="graf graf--p graf-after--p">…&gt; SELECT * FROM Track WHERE AlbumID=2 ORDER BY AlbumOrder;</p><p name="6e7d" id="6e7d" class="graf graf--p graf-after--p">TABLE Track WITH INDEX TrackAlbumIDOrderIndex ORDER BY</p><p name="f161" id="f161" class="graf graf--p graf-after--p">**提前做它</p><p name="298e" id="298e" class="graf graf--p graf-after--p">Results of expensive calculations can be precomputed <strong class="markup--strong markup--p-strong">• </strong>Example: Recurring events</p><p name="b3b2" id="b3b2" class="graf graf--p graf-after--p">■ Recurring events can take a long time to expand<br> ■ Meeting on first Monday, Wednesday, and Friday of every month</p><p name="d8a4" id="d8a4" class="graf graf--p graf-after--p">except February ■ Solution</p><p name="3a77" id="3a77" class="graf graf--p graf-after--p">■ Pre-expand recurrences into occurrences ■ Store occurrences in database</p><p name="332f" id="332f" class="graf graf--p graf-after--p">2，内存增长的意识</p><p name="f844" id="f844" class="graf graf--p graf-after--p">再计算或者缓存特定的对象有一个大的内存冲撞；缓存图像特别是造成困难的，例如，位图的背部给对象的生命周期在内存中持久化</p><p name="63d0" id="63d0" class="graf graf--p graf-after--p">**以后做它</p><p name="0610" id="0610" class="graf graf--p graf-after--p">异步加载：同步地显示数据是一个更好的用户体验；如果不可能，使用GCD或者其他API区推迟工作，例如。日历</p><p name="368e" id="368e" class="graf graf--p graf-after--p">启动到没有时间的响应的界面，事件是被异步加载的</p><p name="65d9" id="65d9" class="graf graf--p graf-after--p">***等级化去做它</p><p name="44f8" id="44f8" class="graf graf--p graf-after--p">例如一个联系人的App，随着联系人的增多会启动越来越慢，</p><p name="05f2" id="05f2" class="graf graf--p graf-after--p">给大的数据集合等级化：</p><p name="e8e4" id="e8e4" class="graf graf--p graf-after--p">1，使得挑剔的方法快</p><p name="3fa9" id="3fa9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">• Loading sections</strong></p><p name="7f0a" id="7f0a" class="graf graf--p graf-after--p">-numberOfSectionsInTableView:</p><p name="c122" id="c122" class="graf graf--p graf-after--p">-tableView:titleForHeaderInSection:</p><p name="aee0" id="aee0" class="graf graf--p graf-after--p">-tableView:numberOfRowsInSection:</p><p name="7f36" id="7f36" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Loading the index bar</strong></p><p name="fc0a" id="fc0a" class="graf graf--p graf-after--p">-tableView:sectionIndexTitlesForTableView</p><p name="163c" id="163c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Loading visible cells</strong></p><p name="12fc" id="12fc" class="graf graf--p graf-after--p">-tableView:cellForRowAtIndexPath:</p><p name="1962" id="1962" class="graf graf--p graf-after--p">2，加载section信息</p><p name="be25" id="be25" class="graf graf--p graf-after--p">1，UITableView要求section数量和</p><p name="fddd" id="fddd" class="graf graf--p graf-after--p">*缓慢:加载完全的数据集合并且分组到section中</p><p name="8bbf" id="8bbf" class="graf graf--p graf-after--p">*快：独立存储section数量</p><p name="e4b0" id="e4b0" class="graf graf--p graf-after--p">2，CoreData用户得到这个免费</p><p name="b617" id="b617" class="graf graf--p graf-after--p">-[NSFetchedResultsController initWithFetchRequest:(NSFetchRequest *)fetchRequest</p><p name="3740" id="3740" class="graf graf--p graf-after--p">managedObjectContext:(NSManagedObjectContext *)context</p><p name="c0bc" id="c0bc" class="graf graf--p graf-after--p">sectionNameKeyPath:(NSString *)sectionNameKeyPath</p><p name="72be" id="72be" class="graf graf--p graf-after--p">cacheName:(NSString *)name]</p><p name="80ca" id="80ca" class="graf graf--p graf-after--p">***性能策略-轮廓你的 App，消除额外的工作，用较大的数据集合去测试</p><p name="df1e" id="df1e" class="graf graf--p graf-after--p">**事件处理：</p><p name="96f3" id="96f3" class="graf graf--p graf-after--p">1，用户事件在主线程的runloop中的进程中，用户事件包括，触摸，滑动，接近传感器，加速器</p><p name="e6af" id="e6af" class="graf graf--p graf-after--p">2，keep main run thread free to process events</p><p name="ec03" id="ec03" class="graf graf--p graf-after--p">最优化事件处理：</p><p name="ce43" id="ce43" class="graf graf--p graf-after--p">A,在主线程中最佳化CPU时间(性能策略也适用于事件处理；用time profiler去控制多事之地；B,不要阻塞主线程；C,Move WORK OFF MAIN THREAD-二种策略：显式同时发生</p><p name="af25" id="af25" class="graf graf--p graf-after--p">GCD：read a file off the main thread</p><p name="c876" id="c876" class="graf graf--p graf-after--p">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),</p><p name="96c5" id="96c5" class="graf graf--p graf-after--p">^{</p><p name="49b5" id="49b5" class="graf graf--p graf-after--p">NSError *err = nil;</p><p name="ef09" id="ef09" class="graf graf--p graf-after--p">NSStringEncoding encoding;</p><p name="deea" id="deea" class="graf graf--p graf-after--p">NSString *myText = [NSString stringWithContentsOfFile:myFile</p><p name="fccc" id="fccc" class="graf graf--p graf-after--p">usedEncoding:&amp;encoding error:&amp;err];</p><p name="313f" id="313f" class="graf graf--p graf-after--p">if (err == nil) {</p><p name="934c" id="934c" class="graf graf--p graf-after--p">dispatch_async(dispatch_get_main_queue(), ^{</p><p name="3d90" id="3d90" class="graf graf--p graf-after--p">[myTextField setText:myText];</p><p name="9be4" id="9be4" class="graf graf--p graf-after--p">});</p><p name="85b4" id="85b4" class="graf graf--p graf-after--p">}</p><p name="4ddc" id="4ddc" class="graf graf--p graf-after--p">});</p><p name="62de" id="62de" class="graf graf--p graf-after--p">#GCD理解</p><p name="3bd5" id="3bd5" class="graf graf--p graf-after--p">太多线程：1，太多线程：并行队列-ok，增加一些block-ok，这个block带一个长的block调用-bad：</p><p name="13db" id="13db" class="graf graf--p graf-after--p">解决方案：1，序列化队列；2派发资源。3：带有限制的NSOperation队列；4，NSURLConnection的异步方法</p><p name="fe98" id="fe98" class="graf graf--p graf-after--p">2，线程安全：a：主线程仅仅属于UIKit，当然也有例外-UIGraphics，UIBeizerPath，UIImage</p><p name="0c4b" id="0c4b" class="graf graf--p graf-after--p">b，任何用同步的线程-大多数的CG,CAFoudation不能同时同二个线程存取</p><p name="9753" id="9753" class="graf graf--p graf-after--p">c，线程安全-OC反省</p><p name="1916" id="1916" class="graf graf--p graf-after--p">粗鲁的锁在线程安全中能导向连接；用系统的踪迹去发现竞争的资源</p><p name="4889" id="4889" class="graf graf--p graf-after--p">NSOperationQueue，NSThread）；隐式同时发生（视图和层的动画，层的创作，PNG的解码；滑动不是一个动画）</p><p name="1c43" id="1c43" class="graf graf--p graf-after--p graf--trailing">GC</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/ios-app-development" class="p-tag">iOS App Development</a>, <a href="https://medium.com/tag/ios" class="p-tag">iOS</a></p><p>By <a href="https://medium.com/@ZhaoPink" class="p-author h-card">Marc Steven</a> on <a href="https://medium.com/p/eb2d620d8220"><time class="dt-published" datetime="2017-01-12T23:49:42.052Z">January 12, 2017</time></a>.</p><p><a href="https://medium.com/@ZhaoPink/ios-app%E6%80%A7%E8%83%BD%E4%B9%8B%E5%93%8D%E5%BA%94%E7%AF%87-eb2d620d8220" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 23, 2017.</p></footer></article>

</body></html>